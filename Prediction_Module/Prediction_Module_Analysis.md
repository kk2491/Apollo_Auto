# Prediction Module Analysis
## Function:
Predict the motion trajectory of the obstacle, and each trajectory has a probability value.

## Input:
 * Vehicle location information: /apollo/localization/pose([pb_msgs/LocalizationEstimate]). <br />
 * Obstacle information: /apollo/perception/obstacles([pb_msgs/PerceptionObstacles]).

## Output:
The trajectory of the obstacle. /apollo/prediction[pb_msgs/PredictionObstacle].

## Node graph:
![prediction data flow](images/prediction_node_arch.bmp)

## submodule:
 * Container: Stores the data in the subscription topic. <br />
 * Evaluator: For any obstacle, the evaluator predicts the path and speed. An evaluator implements the evaluation by giving a probability value to each path using the evaluation model under _prediction/data/_. <br />
 * Predictor: The predictor passes the obstacle prediction, and the current channel contains the following:<br />
   * Lane sequence: obstacles can only move according to the lane.<br />
   * Free movement: obstacles move freely.<br />
   * Area priming: obstacles can only move in certain areas.<br />

## Source architecture:
 * main.cc: Starts the /prediction node.<br />
 * prediction.cc and prediction.h:<br />
* Name() function: Returns the node name prediction.<br />
* Init() function:<br />
       * Use the configuration file prediction_conf.pb.txt to set the prediction_conf_, which mainly sets the channel type generated by the preditor.<br />
       * Set the node topic type using the configuration file adapter.conf to set the adapter_conf_.<br />
       * Initialize the AdapterManager, defining the nodehandle and the topic.<br />
       * Initialize the ContainerManager, each accepts a topic to create a Container for accepting topic data.<br />
       * Initialize EvaluatorManager: Register an Evaluator: MLP_EVALUATOR; configure MLP_EVALUATOR according to prediction_conf.pb.txt, it seems to focus on the vehicle on the road, set vehicle_on_lane_evaluator_.<br />
       * Initialize PredictorManager: Register four Predictors and set vehicle_on_lane_predictor_, vehicle_off_lane_predictor_ and pedestrian_predictor_.<br />
       * Check if the localization and reception nodes are ready.<br />
       * Set localization and exception data callback functions OnLocalization and OnPerception.<br />
* OnLocalization function:<br />
       * Get the obstacle container obstacles_container.<br />
       * Get the position pose_container.<br />
       * Save the newly arrived location message to pose_container.<br />
       * Convert location to obstacle information (not sure how to convert ://TODO)<br />
       * Update obstacle information.<br />
* OnPerception function:<br />
       * Get the obstacle container obstacles_container.<br />
       * Store newly arrived obstacle information in obstacles_container.<br />
       * Run Evaluator.<br />
       * Run Predictor.<br />
       * Publish the message with the new data to the publication_obstacles header structure.<br />

## Evaluator Evaluator:
 * Create a new NewEvaluator:<br />
   * data/mlp_vehicle_model.bin: The core part of the evaluator implemented with deep learning.<br />
   * The configuration output of the feature.proto or lane_graph.proto file is unclear.<br />
   * In the evaluator/vehicle/ directory, implement a new evaluator class NewEvaluator based on the Evaluator. And refer to the mlp_evaluator implementation class.<br />
   * The new evaluator class implemented in the prediction_conf.pb.txt file is specified.<br />
   * Modify the evaluator class used by default in evaluator_manager.h.<br />
 * Run() function in evaluator_manager.cc:<br />
   * Get the obstacle container container.<br />
   * Traverse all obstacles and use the obstacle id and obstacle container to obtain obstacle information obstacle.<br />
   * For obstacles on the lane, call Evaluate for evaluation.<br />
 * Evaluate() function in mlp_evaluator.cc:<br />
   * Take a single obstacle as a parameter. Calculate the feature of a single obstacle and calculate its probability.<br />
   * Multiple lane_graph_ptr is included in each obstacle_ptr.<br />
   * Calculate feature_values ​​using obstacle_ptr and lane_graph_ptr<br />
   * The probability value probability is calculated by feature_values.<br />
   * Set the probability value probability to lane_sequence_ptr.<br />
   * Further analysis needs to understand the concept of feature and lane_sequence, which requires access to the algorithm, and the temporary evaluator is here.<br />

## Predictor:
 * Function: Predict the future trajectory of obstacles.<br />
 * Create a new predictor, NewPredictor:<br />
   * Create a new directory vehicle under predictor/.<br />
   * Create new_predictor.h and new_predictor.cc in the vehicle directory, mainly inheriting from the Predictor class definition and implementing the subclass NewPredictor. Specific implementation can refer to the vehicle peer directory free_move and so on.<br />
   * Update the configuration file prediction_conf.pb.txt to add a new predictor type.<br />
   * Update the manager to modify the default predictor type in the file predictor_manager.h.<br />
 * The run() function in prediction_manager.cc:<br />
   * Get the obstacle container container.<br />
   * Set the timestamp of the predicted obstacle.<br />
   * Obtain obstacle information obstacle based on the id and container in the predicted obstacle.<br />
   * Set the type predictor of the predictor based on the type in the predicted obstacle.<br />
   * Pass the obstacle information and execute the predictor predictor->Predict(obstacle).<br />
   * Configure all tracks of obstacles into the predicted obstacles. And update the timestamp.<br />
 * Predictor function Predict() function:<br />
   * Get the feature based on the obstacle information.<br />
   * Get num_lane_sequence by feature.<br />
   * Traverse num_lane_sequence and get the sequence by feature.<br />
   * Get curr_lane_id from the sequence.<br />
   * Get the TrajectoryPoint from the curr_lane_id via the DrawLaneSequenceTrajectoryPoints() function.<br />
   * Obtain trajectory from TrajectoryPoint via the GenerateTrajectory() function.<br />
   * Set the probability of the trajectory and store it in the trajectories_vector.<br />
   * Similar to Evaluator, further analysis requires specific algorithms, and is here for the time being.<br />
