# Prediction Module Analysis
## Function:
Predict the motion trajectory of the obstacle, and each trajectory has a probability value.

## Input:
 * Vehicle location information: /apollo/localization/pose([pb_msgs/LocalizationEstimate]).
 * Obstacle information: /apollo/perception/obstacles([pb_msgs/PerceptionObstacles]).

## Output:
The trajectory of the obstacle. /apollo/prediction[pb_msgs/PredictionObstacle].

## Node graph:
![prediction data flow](images/prediction_node_arch.bmp)

## submodule:
 * Container: Stores the data in the subscription topic.
 * Evaluator: For any obstacle, the evaluator predicts the path and speed. An evaluator implements the evaluation by giving a probability value to each path using the evaluation model under _prediction/data/_.
 * Predictor: The predictor passes the obstacle prediction, and the current channel contains the following:
   * Lane sequence: obstacles can only move according to the lane.
   * Free movement: obstacles move freely.
   * Area priming: obstacles can only move in certain areas.

## Source architecture:
 * main.cc: Starts the /prediction node.
 * prediction.cc and prediction.h:
* Name() function: Returns the node name prediction.
* Init() function:
       * Use the configuration file prediction_conf.pb.txt to set the prediction_conf_, which mainly sets the channel type generated by the preditor.
       * Set the node topic type using the configuration file adapter.conf to set the adapter_conf_.
       * Initialize the AdapterManager, defining the nodehandle and the topic.
       * Initialize the ContainerManager, each accepts a topic to create a Container for accepting topic data.
       * Initialize EvaluatorManager: Register an Evaluator: MLP_EVALUATOR; configure MLP_EVALUATOR according to prediction_conf.pb.txt, it seems to focus on the vehicle on the road, set vehicle_on_lane_evaluator_.
       * Initialize PredictorManager: Register four Predictors and set vehicle_on_lane_predictor_, vehicle_off_lane_predictor_ and pedestrian_predictor_.
       * Check if the localization and reception nodes are ready.
       * Set localization and exception data callback functions OnLocalization and OnPerception.
* OnLocalization function:
       * Get the obstacle container obstacles_container.
       * Get the position pose_container.
       * Save the newly arrived location message to pose_container.
       * Convert location to obstacle information (not sure how to convert ://TODO)
       * Update obstacle information.
* OnPerception function:
       * Get the obstacle container obstacles_container.
       * Store newly arrived obstacle information in obstacles_container.
       * Run Evaluator.
       * Run Predictor.
       * Publish the message with the new data to the publication_obstacles header structure.

## Evaluator Evaluator:
 * Create a new NewEvaluator:
   * data/mlp_vehicle_model.bin: The core part of the evaluator implemented with deep learning.
   * The configuration output of the feature.proto or lane_graph.proto file is unclear.
   * In the evaluator/vehicle/ directory, implement a new evaluator class NewEvaluator based on the Evaluator. And refer to the mlp_evaluator implementation class.
   * The new evaluator class implemented in the prediction_conf.pb.txt file is specified.
   * Modify the evaluator class used by default in evaluator_manager.h.
 * Run() function in evaluator_manager.cc:
   * Get the obstacle container container.
   * Traverse all obstacles and use the obstacle id and obstacle container to obtain obstacle information obstacle.
   * For obstacles on the lane, call Evaluate for evaluation.
 * Evaluate() function in mlp_evaluator.cc:
   * Take a single obstacle as a parameter. Calculate the feature of a single obstacle and calculate its probability.
   * Multiple lane_graph_ptr is included in each obstacle_ptr.
   * Calculate feature_values ​​using obstacle_ptr and lane_graph_ptr
   * The probability value probability is calculated by feature_values.
   * Set the probability value probability to lane_sequence_ptr.
   * Further analysis needs to understand the concept of feature and lane_sequence, which requires access to the algorithm, and the temporary evaluator is here.

## Predictor:
 * Function: Predict the future trajectory of obstacles.
 * Create a new predictor, NewPredictor:
   * Create a new directory vehicle under predictor/.
   * Create new_predictor.h and new_predictor.cc in the vehicle directory, mainly inheriting from the Predictor class definition and implementing the subclass NewPredictor. Specific implementation can refer to the vehicle peer directory free_move and so on.
   * Update the configuration file prediction_conf.pb.txt to add a new predictor type.
   * Update the manager to modify the default predictor type in the file predictor_manager.h.
 * The run() function in prediction_manager.cc:
   * Get the obstacle container container.
   * Set the timestamp of the predicted obstacle.
   * Obtain obstacle information obstacle based on the id and container in the predicted obstacle.
   * Set the type predictor of the predictor based on the type in the predicted obstacle.
   * Pass the obstacle information and execute the predictor predictor->Predict(obstacle).
   * Configure all tracks of obstacles into the predicted obstacles. And update the timestamp.
 * Predictor function Predict() function:
   * Get the feature based on the obstacle information.
   * Get num_lane_sequence by feature.
   * Traverse num_lane_sequence and get the sequence by feature.
   * Get curr_lane_id from the sequence.
   * Get the TrajectoryPoint from the curr_lane_id via the DrawLaneSequenceTrajectoryPoints() function.
   * Obtain trajectory from TrajectoryPoint via the GenerateTrajectory() function.
   * Set the probability of the trajectory and store it in the trajectories_vector.
   * Similar to Evaluator, further analysis requires specific algorithms, and is here for the time being.
